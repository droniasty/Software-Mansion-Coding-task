void swap(int *a, int *b) {
  int s=*a;
  *a=*b;
  *b=s;
}

int partition(int T[], int p, int k) {
  int pivot = T[k];
  int i = (p-1);
  for (int j=p; j<k; j++) {
    if (T[j]<=pivot) {
      i++;
      swap(&T[i], &T[j]);
    }
  }
  swap(&T[i+1],&T[k]);
  return (i + 1);
}


void quicksort(int T[], int p, int k)
{
    if (p<k) {
    int s = partition(T,p,k);
    quicksort(T, p, s - 1);
    quicksort(T, s + 1, k);
  }
}

int binsearch(int T[], int x, int p, int k)
{//Binsearch finding last occurrence of integer x in array T
    while(p<k)
    {
        int s=(p+k+1)/2;
        if(T[s]>x)k=s-1;
        else p=s;
    }
    return k;
}

bool in_array(int T[], int n, int x)
{//Function finding whether array contains given element. time complexity:O(log n)
    int in=binsearch(T,x,0,n-1);
    return (T[in]==x);
}

bool prime(int n)
{//primality test
    if(n==2||n==3)return true;
    bool p=(n>1&&n%2&&n%3);
    for(int i=5; i<=sqrt(n)&&p; i+=6)
    {
        p=(n%i&&n%(i+2));
    }
    return p;
}

int bad_numbers(int **P, int B[], int b)
{//A function that creates an array of integers that are present a prime number of times in sequence B and returns its size.
    int *T=(int*)malloc(b*sizeof(int));
    int s=0;
    int p=0;
    while(p<b)
    {
        int q=binsearch(B,B[p],p,b-1);
        if(prime(b-q+1))
        {
            T[s]=B[p];
            s++;
        }
        p=q+1;
    }
    T=realloc(T,s*sizeof(int));
    *P=T;
    return s;
}

void funkcja(int A[], int a, int B[], int b, int **C)
{
    int *T=(int*)malloc(a*sizeof(int));
    quicksort(B,0,b-1);
    int* P;
    int s=bad_numbers(&P,B,b);
    int c=0;
    for(int i=0; i<a; i++)
    {
        if(!in_array(P,s,A[i]))
        {
            T[c]=A[i];
            c++;
        }
    }
    T=realloc(T,c*sizeof(int));
    free(P);
    *C=T;
}
